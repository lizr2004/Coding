#[RQNOJ 311](https://www.rqnoj.cn/problem/311)
##题面
###题目描述
今年是国际数学联盟确定的“2000——世界数学年”，又恰逢我国著名数学家华罗庚先生诞辰90周年。在华罗庚先生的家乡江苏金坛，组织了一场别开生面的数学智力竞赛的活动，你的一个好朋友XZ也有幸得以参加。活动中，主持人给所有参加活动的选手出了这样一道题目:
设有一个长度N的数字串，要求选手使用K个乘号将它分成K+1个部分，找出一种分法，使得这K+1个部分的乘积能够为最大。
同时，为了帮助选手能够正确理解题意，主持人还举了如下的一个例子：
有一个数字串: 312，当N=3，K=1时会有以下两种分法：

	1）3*12=36
	2）31*2=62
这时，符合题目要求的结果是： 31*2=62
现在，请你帮助你的好朋友XZ设计一个程序，求得正确的答案。
###输入格式
程序的输入共有两行:
第一行共有2个自然数N,K (6<=N<=40，1<=K<=30)
第二行是一个长度为N的数字串。
###输出格式
相对于输入，应输出所求得的最大乘积（一个自然数）。
###样例输入 
	4 2
	1231
###样例输出 
	62
##分析
###预处理
预处理出num数组：num\[i]\[j]表示从第i个数到第j个数的数字，如当数字串为312时
num数组为

	3  31 312
	0   1  12
	0   0   2
###状态
dp\[i]\[j]表示考虑了前i个，分割j次的最大乘积。
###转移
	dp[a][b]=max(dp[a][b],dp[m-1][b-1]*num[m][a]);
其中a表示这一段的终点，b表示这是第b个断点，m表示这一段的起点。
###枚举顺序
按a,b,m的顺序枚举。
##代码
```
#include <iostream>
using namespace std;
long long num[50][50];
long long dp[50][50];
char s[50];
int N,K;
int main()
{
    cin>>N>>K;
	cin>>s;
	for(int a=0;a<N;a++)
	{
		num[a][a]=s[a]-'0';
		for(int b=a+1;b<N;b++)
			num[a][b]=num[a][b-1]*10+(s[b]-'0');
	}
	for(int a=0;a<N;a++)
		dp[a][0]=num[0][a];
	for(int a=0;a<N;a++)
		for(int b=0; b<=K && b<a+1 ;b++)
			for(int m=b;m<=a;m++)
				dp[a][b]=max(dp[a][b],dp[m-1][b-1]*num[m][a]);
	cout<<dp[N-1][K]<<endl;
	return 0;
}
```
