#RQNOJ 252
##题面
###题目描述
dd_engi所在的TIANYI公司要举办一次盛大的公司聚会。可惜的是，由于场地和花费的原因，不可能所有人都参加。现在的任务是拟定参加聚会人员的名单。
TIANYI公司的组织架构可以看做一棵有根多叉树。也就是说，在编号为1~N的所有N名员工中，除了最高管理者（编号为1）以外，每个员工都有且仅有一位直接上司；最高管理者则是这棵多叉树的“根”。这很好理解，对吗？另外，我们保证，员工的编号会大于他的直接上司的编号。
不同的员工对于聚会有着不同的要求，事实上，若邀请第i位员工（编号为i），在聚会中满足他的要求需要花费Ci元。另一方面，不同的员工在聚会中的“兴奋指数”也不同，第i位员工参加聚会的兴奋指数是Ei。
选择参加聚会的人员还有一个限制：为了使参加聚会的员工能够尽量放松，若邀请了某位员工，就不能邀请他的任何一位上司。这里“上司”的定义是这样的：最高管理者没有上司，其余所有员工的直接上司以及直接上司的所有上司都是他的上司。换句话说，某位员工的上司就是树中从他的节点走到根节点的路径上经过的所有节点（包括根结点，但不包括他自身）。
在满足上述限制的前提下，dd_engi希望参加聚会人员的兴奋指数之和最大，但同时他被告知，满足所有参加聚会人员的要求的总花费不得超过M元。那么，参加聚会人员的名单究竟应该怎样确定才最优呢？你需要求出的是最大的总兴奋指数。
###数据范围
30%的数据满足N<=20。
100%的数据满足1 <= N <= 1024, 0 <= M <= 109, 0 <= Ci <= 1024, -1024 <= Ei <= 1024。
###输入格式
第一行，两个空格隔开的整数，N与M。
第二行，N-1个整数，分别是第2位至第N位员工的直接上司的编号。
第三行，N个整数，分别是C1、C2……CN。
第四行，N个整数，分别是E1、E2……EN。
###输出格式
只需输出一行一个整数，即最大的总兴奋指数。
###样例输入 
	10 100
	1 2 2 1 4 3 5 6 1
	12 53 127 32 164 22 199 10 19 17
	-1 0 3 5 7 -2 9 6 8 13
###样例输出 
	27
##分析
###思路
本题乍一看像是在树上dp，但是复杂度过高，代码难写（至少我没有想出来），才发现此题是**线性DP**。
###状态
我们用dp\[i]\[j]表示在i及其子树的人中，使用j的钱得到的最大兴奋指数。
###转移
从后往前枚举员工，因为保证员工编号大于上司，我们想要从叶子结点向上dp，所以这样进行dp，转移时有员工转移向上司。
转移时，先检查使自身最优（不要存在兴奋质数小于自己的情况）然后进行更新，对父节点的每一个价值，进行转移，转移时方程如下

	dp[fa[i]][j]=max(dp[fa[i]][j],dp[fa[i]][j-k]+dp[i][k]);
k表示本员工及其下属的钱数，j表示被更新的父节点的钱数，i是本节点。
##代码如下
```
#include <iostream>
#include <stdio.h>
#include <string.h>
using namespace std;
int i,j,k,n,m,fa[2001],c[2001],e[2001],dp[2001][201];
int main()
{
	cin>>n>>m;
	for(i=2;i<=n;i++)cin>>fa[i];
	for(i=1;i<=n;i++)cin>>c[i];
	for(i=1;i<=n;i++)cin>>e[i];
	for(i=n;i>=1;i--)
	{
		for(j=m;j>=c[i];j--)
			dp[i][j]=max(dp[i][j],e[i]);
		for(j=m;j>=0;j--)
			for(k=0;k<=j;k++)
				dp[fa[i]][j]=max(dp[fa[i]][j],dp[fa[i]][j-k]+dp[i][k]);
	}
	int ans=0;
	for(i=0;i<=m;i++)
		if(ans<dp[1][i])ans=dp[1][i];
	cout<<ans<<endl;
	return 0;
}
```