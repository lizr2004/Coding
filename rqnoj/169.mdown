#RQNOJ 169
##题面
###题目描述
假设某条街上每一公里就有一个公共汽车站，并且乘车费用如下表：
公里数	1	2	3	4	5	6	7	8	9	10
费用	12	21	31	40	49	58	69	79	90	101
而任意一辆汽车从不行驶超过10公里。某人想行驶n公里，假设他可以任意次换车，请你帮他找到一种乘车方案，使得总费用最小
注意：10公里的费用比1公里小的情况是允许的。
###输入格式
共两行，第一行为10个不超过200的整数，依次表示行驶1～10公里的费用，相邻两数间用一个空格隔开；第二行为某人想要行驶的公里数(<=100)。
###输出格式
仅一行，包含一个整数，表示行使这么远所需要的最小费用。
###样例输入 
	12 21 31 40 49 58 69 79 90 101 
	15
###样例输出 
	147
##分析
###状态
	dp[i]表示走 i KM的费用
###转移
显然，每一个dp\[i]都可以由dp\[i-k]得到(k<=10,i-k>=0)
###转移顺序
- 枚举被更新的dp\[i]
- 枚举k(意义同上)
- 更新

###初值
dp\[i]=0;
##代码
```
#include <iostream>
#define maxn 1000
using namespace std;
long dis,a[11],f[maxn],n,i,j;
int main()
{
	for (i=1;i<=10;i++)
		cin>>a[i];
	cin>>dis;
	for (j=1;j<=dis;j++)
	{
		f[j]=0x3f3f3f3f;
		for (i=1;i<=10;i++)
			if (j-i>=0 && f[j-i]+a[i]<f[j])
				f[j]=f[j-i]+a[i];
	}
	cout<<f[dis]<<endl;
	return 0;
} 
```